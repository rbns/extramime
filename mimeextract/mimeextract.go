// mimeextract fetches a list of extension to mimetype mappings from
// the nginx source repository and creates a source file to be used by
// extramime (or other tools, if thats useful..)
package main

import (
	"fmt"
	"flag"
	"net/http"
	"log"
	"strings"
	"io"
	"bufio"
	"text/template"
	"os"
	"time"
)

// Url of the mime type definitions in the nginx source repository
const nginxURL = "http://trac.nginx.org/nginx/export/6345822f0abb70807f635989b6c2df7852a55bd9/nginx/conf/mime.types"

// Template of the genrated go file
const goTemp = `// autogenerated on {{ .Date }} by github.com/rbns/extramime/mimeextract
// used mime definitions:
// {{ .Url }}
package {{ .Pkg }}

type MimeInfo struct {
	Extension	string
	Type		string
}

var mimes = []MimeInfo {
	{{ range $v := .Mimes }}{{ $v }},
	{{end}}
}
`

var pkg = flag.String("p", "extramime", "Package name to generate for")
var out = flag.String("o", "types.go", "Output file")
var url = flag.String("url", nginxURL, "Url from where to fetch the mime types")

func init() {
	flag.Parse()
}

func main() {
	resp, err := http.Get(*url)
	if err != nil {
		log.Fatal(err)
	}
	defer resp.Body.Close()

	mimes, err := parseNginx(resp.Body)
	if err != nil {
		log.Fatal(err)
	}
	defer resp.Body.Close()

	file, err := os.Create(*out)
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	err = generateGo(file, mimes)
	if err != nil {
		log.Fatal(err)
	}
}

// A pair of extension and mimetype
type MimeInfo struct {
	Extension	string
	Type	string
}

func (m MimeInfo)String() string {
	return fmt.Sprintf("MimeInfo{Extension: \"%v\", Type: \"%v\"}", m.Extension, m.Type)
}

// parses an nginx mime type definition in the format
//
// types {
//		text/plain		txt text foo;
//		text/html		htm html bar;
//		...
// }
//
// It returns a slice of MimeInfo
func parseNginx(data io.Reader) ([]MimeInfo, error) {
	mimes := make([]MimeInfo, 0)

	s := bufio.NewScanner(data)

	for s.Scan() {
		text := s.Text()
		text = strings.TrimRight(text, ";")

		if !strings.ContainsRune(text, '/') {
			continue	
		}

		f := strings.Fields(text)
		if len(f) < 2 {
			continue
		}

		for _, ext := range f[1:] {
			mimes = append(mimes, MimeInfo{Extension: "." + ext, Type: f[0]})
		}
	}

	return mimes, s.Err()
}

// Write a go source file containing the mime type information
func generateGo(file *os.File, mimes []MimeInfo) error {
	t, err := template.New("go").Parse(goTemp)
	if err != nil {
		return err
	}

	data := struct {
		Date	string
		Url  string
		Pkg	 string
		Mimes []MimeInfo
		}{ Date: time.Now().Format("2006-01-02"), Url: *url, Pkg: *pkg, Mimes: mimes }

	return t.Execute(file, data)
}
